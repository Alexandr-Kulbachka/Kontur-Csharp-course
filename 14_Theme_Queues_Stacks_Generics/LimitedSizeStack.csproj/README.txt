В этой задаче вам нужно реализовать стек ограниченного размера. Этот стек работает как обычный стек, 
однако при превышении максимального размера удаляет самый глубокий элемент в стеке. 
Таким образом в стеке всегда будет ограниченное число элементов.

Вот пример работы такого стека с ограничением в 2 элемента:

// сначала стек пуст
stack.Push(10); // в стеке 10
stack.Push(20); // в стеке 10, 20
stack.Push(30); // в стеке 20, 30
stack.Push(40); // в стеке 30, 40
stack.Pop(); // возвращает 40, в стеке остаётся 30
stack.Pop(); // возвращает 30, стек после этого пуст

Операция Push должна иметь сложность O(1), то есть никак не зависеть от размера стека.

Скачайте проект LimitedSizeStack. Реализуйте класс LimitedSizeStack.

Отладьте его реализацию с помощью тестов в классе LimitedSizeStack_should. Проверьте эффективность операции 
Push с помощью теста из класса LimitedSizeStack_PerformanceTest.
Эффективность метода Last()

У каждой коллекции в C# доступен метод расширения Last(). Однако, работает он за O(1) только для коллекций, 
реализующих интерфейс IList (список с доступом к элементам по индексу). Для остальных коллекций он работает за O(N), 
перебирая её элементы до конца. Будьте осторожны.

-----------------------------------------------------------------------------------------------------------------------

Продолжайте работу в том же проекте LimitedSizeStack.

Если вы запустите проект на исполнение, то увидите окно приложения, в котором можно добавлять новые дела и удалять уже 
существующие. Однако кнопка "Отмена" пока не работает. Ваша задача — сделать так, чтобы эта кнопка отменяла последнее 
действие пользователя.

Изучите класс ListModel — в нём реализована логика работы кнопок в приложении.

Реализуйте методы Undo и CanUndo. Для этого нужно хранить историю последних limit действий удаления/добавления. 
Используйте для этого класс LimitedSizeStack из прошлой задачи. Его не нужно включать в отправляемый на проверку файл, 
считайте, что этот класс уже есть в проекте.

    Метод Undo отменяет последнее действие из истории.
    Метод CanUndo возвращает true, если на данный момент история действий не пуста, то есть если вызов Undo будет 
корректным. Иначе метод должен вернуть false.

Проверить корректность своего решения можно на модульных тестах из класса ListModel_Should и ListModel_PerformanceTest.

Если хотите, можете воспользоваться классическим объектно-ориентированным шаблоном Команда. Однако для сдачи данной задачи,
точно следовать этому шаблону необязательно.